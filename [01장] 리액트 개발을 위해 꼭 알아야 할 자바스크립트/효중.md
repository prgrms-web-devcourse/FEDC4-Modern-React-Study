## 리액트 개발을 위해 꼭 알아야 할 자바스크립트

리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 props의 동등 비교에 따른 결과
이다.

이 props의 동등 비교가 객체의 얕은 비교를 기반으로 이루어진다.

![](https://jinyisland.kr/assets/js/datatypes.png)

### 원시 타입

객체가 아닌 모든 타입을 의미한다. 객체가 아니므로 이런 타입은 메서드가 없다.

원시 타입

- boolean
- null
- undefined
- number
- string
- symbol : 중복되지 않는 어떤 고유한 값을 나타내기 위해 만들어진 타입. Symbol()
  을 사용해서 제작 가능.

```js
ex. const key = Symbol('key')
```

- bigint : number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새
  롭게 나온 타입. 2^53 - 1 보다 더 큰 숫자를 저장 가능

객체 타입

- object : 참조를 전달해서 참조 타입이라고 불린다.

```js
typeof [] === 'object'; // true
typeof {} === 'object'; //true

const hello1 = function () {};

const hello2 = function () {};

//육안으로는 같아보여도 참조가 다르다.
hello === hello2; // false
```

### 값을 저장하는 방식의 차이

- 원시 타입은 불변 형태의 값으로 저장
- 객체 타입은 변경 가능한 형태로 저장, 값을 복사할 때도 값이 아닌 참조를 전달

항상 객체 간의 비교가 발생하면 , 이 객체 간의 비교는 우리가 이해하는 내부의 값이
같아도 결과가 항상 true가 아닐 수 있다.

### Object.is

두 개의 인수를 받고, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드이다.

- ==는 강제로 타입 변환을 시켜 느슨한 비교 연산자로 작동한다.

- ===는 타입이 다른 경우에 false를 리턴해 엄격한 비교 연산자로 작동한다.

```js
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

### 리액트에서 동등 비교

- 리액트는 Object.is를 기반으로 동등 비교를 하는 shallowEqual함수를 만들어서 사
  용한다.

먼저 Object.is로 비교를 하고, 객체 간 얕은 비교(첫번째 뎁스만 비교)를 실행

```js
//리액트에서의 shallowEqual

function shallowEqual(objA: mixed, objB: mixed): boolean {
  // is는 Object.is를 의미한다.
  // Object.is라고 안한 이유는 폴리필을 적용하기 위해!

  // Object.is는 ===랑 유사하지만, +0,-0을 구분하고, NaN이 같으면 같다고 표기해준다.

  if (is(objA, objB)) {
    return true;
  }

  // null이 아닌 값 -> 객체가 아닌지 판별
  // Object.is를 통과하지 못한 값(3,4)등은 false를 리턴

  if (
    typeof objA !== 'object' ||
    objA === null ||
    typeof objB !== 'object' ||
    objB === null
  ) {
    return false;
  }

  // 이 단계는 객체만 남아있어서 객체끼리 비교
  // 객체의 키의 개수가 다르면 다른 요소기 떄문에 false리턴

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // 키의 개수가 동일한 객체.
  // objA의 키를 모두 순회하면서 키가 objB의 키이면서 값이 같은지 확인한다.

  for (let i = 0; i < keysA.length; i++) {
    const currentKey = keysA[i];

    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !is(objA[currentKey], objB[currentKey])
    ) {
      return false;
    }
  }

  return true;
}
```

코드에서도 보이듯이, 첫번째 객체의 깊이까지의 키만 비교를 하기 때문에, 객체의 깊
이가 깊어지면 비교할 방법이 없어진다.

```js
shallowEqual(
  {
    hello: 'world',
  },
  {
    hello: 'world',
  }
); //true

shallowEqual(
  {
    hello: {
      hi: 'world',
    },
  },
  {
    hello: {
      hi: 'world',
    },
  }
); //false
```

## 함수란 무엇인가?

함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으
로 감싸서 실행 단위로 만들어 놓은 것입니다.

## 함수를 정의하는 4가지 방법

### 함수 선언문

- 가장 일반적인 방식이다!.
- 호이스팅이 가능하므로 코드의 순서에 상관없이 함수를 호출할 수 있다.

### 함수 표현식

- 함수는 '일급 객체'이다.
- 함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며, 할당도 가
  능하다.
- 함수를 변수에 할당하는 것은 당연히 가능하다.
- 호이스팅은 가능하지만 런타임 시점에 함수가 할당되어 작동한다.

### 화살표 함수

- ES6에서 새로 추가된 방식으로, 가독성과 코드의 글자 수가 줄어들어 많이 사용되는
  방식이다.
- 기존 함수와 차이점
  - constructor 사용 불가
  - arguments 없음
  - this 바인딩 차이: 화살표 함수는 함수 자체의 바인딩을 갖지 않는다.

## 다양한 함수 살펴보기

### 즉시 실행 함수 (IIFE: Immediately Invoked Function Expression)

- 함수를 정의하고 그 순간 즉시 실행되는 함수로, 단 한 번만 호출되고 다시금 호출
  할 수 없다.

### 고차 함수

- 함수를 인수로 받거나 결과로 새로운 함수를 반환하는 함수.
- 이 특징을 활용해 고차 컴포넌트(Higher Order Component)를 만들 수 있다.

https://jeonghwan-kim.github.io/2022/05/28/react-high-order-component

### 함수를 만들 때 주의해야 할 사항

- 함수의 부수 효과(side effect)를 최대한 억제하기
- 가능한 함수를 작게 만들기.
- 누구나 이해할 수 있는 이름을 붙이기.
- useEffect나 useCallback을 사용할 때 넘겨주는 콜백 함수에 네이밍을 붙여주면 가
  독성에 도움이 될 수 있다.

```js
useEffect(function apiRequest() {
  // do something
}, []);
```

## 클래스

### 클래스란 무엇인가?

클래스는 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것입니다.

- **constructor**: 객체를 생성하는데 사용하는 특수한 메서드로, 단 하나만 존재할
  수 있으며 여러 개를 사용한다면 에러가 발생합니다. 생성자에서 별 다르게 수행할
  작업이 없다면 생략도 가능합니다.
- **프로퍼티**: 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값입니다
  .
- **getter와 setter**: getter는 클래스에서 무언가 값을 가져올 때 사용하며,
  setter는 클래스 필드에 값을 할당할 때 사용합니다.
- **인스턴스 메서드**: 클래스 내부에 선언한 메서드로, prototype 메서드라고도 합
  니다.
- **정적 메서드**: 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드로,
  this를 사용할 수 없습니다. 전역 유틸 함수를 정적 메서드로 많이 활용합니다.
- **상속**: 'extends' 키워드를 활용하면 기본 클래스를 기반으로 다양하게 파생된
  클래스를 만들 수 있습니다.

### 클래스와 함수의 관계

클래스의 작동을 생성자 함수로 유사하게 재현할 수 있습니다.

### 클로저

클로저는 함수와 함수가 선언된 어휘적 환경의 조합이라고 정의되어 있다.

```js
function add() {
  const a = 10;

  function innerAdd() {
    const b = 20;
    console.log(a + b);
  }

  innerAdd();
}
```

innerAdd 함수는 add 함수의 어휘적 환경, 즉 add 함수 범위 내에서 선언된 변수 a를
참조할 수 있다. 이런 상황을 클로저라고 한다.

result는 add 함수가 반환한 innerAdd 함수를 참조하고 있다. result(20)을 호출하면,
innerAdd 함수가 실행되고, innerAdd 함수 내부의 console.log(a + b);에서 a는 add
함수의 어휘적 환경을 참조하여 값을 가져온다. 이때 a의 값은 add 함수가 실행될 때
결정된 10이다.

### 전역 스코프

먼저 스코프는 변수의 유효 범위를 의미한다. 자바스크립트는 다양한 스코프가 있다.

전역 레벨에 선언하는 것을 전역 스코프라고 한다. 전역 객체에 전역 레벨에서 선언한
스코프가 바인딩된다.

```js
var global = 'global scope';

function hello() {
  console.log(global);
}

console.log(global); //global scope

hello();

console.log(global === window.global); // true
```

### 함수 스코프

자바스크립트는 기본적으로 함수 레벨 스코프를 따른다. {} 블록이 스코프 범위를 결
정하지 않는다.

```js
if (true) {
  var global = 'global scope';
}

console.log(global); //global scope

console.log(global === window.global); // true
```

전역 스코프는 어디서든 값을 꺼내 올 수 있지만, 반대로 말하면 누구나 접근이 가능
하다.

### 리액트와 클로저

클로저의 원리를 사용하고 있는 대표적인 것 중 하나가 useState이다.

```js
function Component() {
  const [state, setState] = useState();

  function handleClick() {
    //useState의 호출은 끝나도 최신 값을 알고 있다. 클로저를 사용해서 가능하다

    setState((prev) => prev + 1);
  }
}
```

꼭 필요한 작업만 남겨 놓고 기억할 수 있도록 구성해야 한다그렇지 않으면 메모리를
불필요하게 잡아먹고 성능에 악영향을 미칠 수 있다.
## 리액트 개발을 위해 꼭 알아야 할 자바스크립트

리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 props의 동등 비교에 따른 결과
이다.

이 props의 동등 비교가 객체의 얕은 비교를 기반으로 이루어진다.

![](https://jinyisland.kr/assets/js/datatypes.png)

### 원시 타입

객체가 아닌 모든 타입을 의미한다. 객체가 아니므로 이런 타입은 메서드가 없다.

원시 타입

- boolean
- null
- undefined
- number
- string
- symbol : 중복되지 않는 어떤 고유한 값을 나타내기 위해 만들어진 타입. Symbol()
  을 사용해서 제작 가능.

```js
ex. const key = Symbol('key')
```

- bigint : number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새
  롭게 나온 타입. 2^53 - 1 보다 더 큰 숫자를 저장 가능

객체 타입

- object : 참조를 전달해서 참조 타입이라고 불린다.

```js
typeof [] === 'object'; // true
typeof {} === 'object'; //true

const hello1 = function () {};

const hello2 = function () {};

//육안으로는 같아보여도 참조가 다르다.
hello === hello2; // false
```

### 값을 저장하는 방식의 차이

- 원시 타입은 불변 형태의 값으로 저장
- 객체 타입은 변경 가능한 형태로 저장, 값을 복사할 때도 값이 아닌 참조를 전달

항상 객체 간의 비교가 발생하면 , 이 객체 간의 비교는 우리가 이해하는 내부의 값이
같아도 결과가 항상 true가 아닐 수 있다.

### Object.is

두 개의 인수를 받고, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드이다.

- ==는 강제로 타입 변환을 시켜 느슨한 비교 연산자로 작동한다.

- ===는 타입이 다른 경우에 false를 리턴해 엄격한 비교 연산자로 작동한다.

```js
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

### 리액트에서 동등 비교

- 리액트는 Object.is를 기반으로 동등 비교를 하는 shallowEqual함수를 만들어서 사
  용한다.

먼저 Object.is로 비교를 하고, 객체 간 얕은 비교(첫번째 뎁스만 비교)를 실행

```js
//리액트에서의 shallowEqual

function shallowEqual(objA: mixed, objB: mixed): boolean {
  // is는 Object.is를 의미한다.
  // Object.is라고 안한 이유는 폴리필을 적용하기 위해!

  // Object.is는 ===랑 유사하지만, +0,-0을 구분하고, NaN이 같으면 같다고 표기해준다.

  if (is(objA, objB)) {
    return true;
  }

  // null이 아닌 값 -> 객체가 아닌지 판별
  // Object.is를 통과하지 못한 값(3,4)등은 false를 리턴

  if (
    typeof objA !== 'object' ||
    objA === null ||
    typeof objB !== 'object' ||
    objB === null
  ) {
    return false;
  }

  // 이 단계는 객체만 남아있어서 객체끼리 비교
  // 객체의 키의 개수가 다르면 다른 요소기 떄문에 false리턴

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // 키의 개수가 동일한 객체.
  // objA의 키를 모두 순회하면서 키가 objB의 키이면서 값이 같은지 확인한다.

  for (let i = 0; i < keysA.length; i++) {
    const currentKey = keysA[i];

    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !is(objA[currentKey], objB[currentKey])
    ) {
      return false;
    }
  }

  return true;
}
```

코드에서도 보이듯이, 첫번째 객체의 깊이까지의 키만 비교를 하기 때문에, 객체의 깊
이가 깊어지면 비교할 방법이 없어진다.

```js
shallowEqual(
  {
    hello: 'world',
  },
  {
    hello: 'world',
  }
); //true

shallowEqual(
  {
    hello: {
      hi: 'world',
    },
  },
  {
    hello: {
      hi: 'world',
    },
  }
); //false
```

## 함수란 무엇인가?

함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으
로 감싸서 실행 단위로 만들어 놓은 것입니다.

## 함수를 정의하는 4가지 방법

### 함수 선언문

- 가장 일반적인 방식이다!.
- 호이스팅이 가능하므로 코드의 순서에 상관없이 함수를 호출할 수 있다.

### 함수 표현식

- 함수는 '일급 객체'이다.
- 함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며, 할당도 가
  능하다.
- 함수를 변수에 할당하는 것은 당연히 가능하다.
- 호이스팅은 가능하지만 런타임 시점에 함수가 할당되어 작동한다.

### 화살표 함수

- ES6에서 새로 추가된 방식으로, 가독성과 코드의 글자 수가 줄어들어 많이 사용되는
  방식이다.
- 기존 함수와 차이점
  - constructor 사용 불가
  - arguments 없음
  - this 바인딩 차이: 화살표 함수는 함수 자체의 바인딩을 갖지 않는다.

## 다양한 함수 살펴보기

### 즉시 실행 함수 (IIFE: Immediately Invoked Function Expression)

- 함수를 정의하고 그 순간 즉시 실행되는 함수로, 단 한 번만 호출되고 다시금 호출
  할 수 없다.

### 고차 함수

- 함수를 인수로 받거나 결과로 새로운 함수를 반환하는 함수.
- 이 특징을 활용해 고차 컴포넌트(Higher Order Component)를 만들 수 있다.

https://jeonghwan-kim.github.io/2022/05/28/react-high-order-component

### 함수를 만들 때 주의해야 할 사항

- 함수의 부수 효과(side effect)를 최대한 억제하기
- 가능한 함수를 작게 만들기.
- 누구나 이해할 수 있는 이름을 붙이기.
- useEffect나 useCallback을 사용할 때 넘겨주는 콜백 함수에 네이밍을 붙여주면 가
  독성에 도움이 될 수 있다.

```js
useEffect(function apiRequest() {
  // do something
}, []);
```

## 클래스

### 클래스란 무엇인가?

클래스는 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것입니다.

- **constructor**: 객체를 생성하는데 사용하는 특수한 메서드로, 단 하나만 존재할
  수 있으며 여러 개를 사용한다면 에러가 발생합니다. 생성자에서 별 다르게 수행할
  작업이 없다면 생략도 가능합니다.
- **프로퍼티**: 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값입니다
  .
- **getter와 setter**: getter는 클래스에서 무언가 값을 가져올 때 사용하며,
  setter는 클래스 필드에 값을 할당할 때 사용합니다.
- **인스턴스 메서드**: 클래스 내부에 선언한 메서드로, prototype 메서드라고도 합
  니다.
- **정적 메서드**: 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드로,
  this를 사용할 수 없습니다. 전역 유틸 함수를 정적 메서드로 많이 활용합니다.
- **상속**: 'extends' 키워드를 활용하면 기본 클래스를 기반으로 다양하게 파생된
  클래스를 만들 수 있습니다.

### 클래스와 함수의 관계

클래스의 작동을 생성자 함수로 유사하게 재현할 수 있습니다.

### 클로저

클로저는 함수와 함수가 선언된 어휘적 환경의 조합이라고 정의되어 있다.

```js
function add() {
  const a = 10;

  function innerAdd() {
    const b = 20;
    console.log(a + b);
  }

  innerAdd();
}
```

innerAdd 함수는 add 함수의 어휘적 환경, 즉 add 함수 범위 내에서 선언된 변수 a를
참조할 수 있다. 이런 상황을 클로저라고 한다.

result는 add 함수가 반환한 innerAdd 함수를 참조하고 있다. result(20)을 호출하면,
innerAdd 함수가 실행되고, innerAdd 함수 내부의 console.log(a + b);에서 a는 add
함수의 어휘적 환경을 참조하여 값을 가져온다. 이때 a의 값은 add 함수가 실행될 때
결정된 10이다.

### 전역 스코프

먼저 스코프는 변수의 유효 범위를 의미한다. 자바스크립트는 다양한 스코프가 있다.

전역 레벨에 선언하는 것을 전역 스코프라고 한다. 전역 객체에 전역 레벨에서 선언한
스코프가 바인딩된다.

```js
var global = 'global scope';

function hello() {
  console.log(global);
}

console.log(global); //global scope

hello();

console.log(global === window.global); // true
```

### 함수 스코프

자바스크립트는 기본적으로 함수 레벨 스코프를 따른다. {} 블록이 스코프 범위를 결
정하지 않는다.

```js
if (true) {
  var global = 'global scope';
}

console.log(global); //global scope

console.log(global === window.global); // true
```

전역 스코프는 어디서든 값을 꺼내 올 수 있지만, 반대로 말하면 누구나 접근이 가능
하다.

### 리액트와 클로저

클로저의 원리를 사용하고 있는 대표적인 것 중 하나가 useState이다.

```js
function Component() {
  const [state, setState] = useState();

  function handleClick() {
    //useState의 호출은 끝나도 최신 값을 알고 있다. 클로저를 사용해서 가능하다

    setState((prev) => prev + 1);
  }
}
```

꼭 필요한 작업만 남겨 놓고 기억할 수 있도록 구성해야 한다그렇지 않으면 메모리를
불필요하게 잡아먹고 성능에 악영향을 미칠 수 있다.
