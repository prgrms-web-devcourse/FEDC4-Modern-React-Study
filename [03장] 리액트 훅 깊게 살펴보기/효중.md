
### 훅은 어디서 오는거지?

우리가 쓰는 react의 여러 훅들은 사실 ReactHooks.js이라는 파일에서 가져온다.

[ReactHooks.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactHooks.js)


```ts
/src/React.js
import {
  createElement as createElementProd,
  createFactory as createFactoryProd,
  cloneElement as cloneElementProd,
  isValidElement,
} from './ReactElement';
import {createContext} from './ReactContext';
import {lazy} from './ReactLazy';
import {forwardRef} from './ReactForwardRef';
import {memo} from './ReactMemo';
import {cache} from './ReactCache';
import {postpone} from './ReactPostpone';
import {
  getCacheSignal,
  getCacheForType,
  useCallback,
  useContext,
  useEffect,
  useEffectEvent,
  useImperativeHandle,
  useDebugValue,
  useInsertionEffect,
  useLayoutEffect,
  useMemo,
  useSyncExternalStore,
  useReducer,
  useRef,
  useState,
  useTransition,
  useDeferredValue,
  useId,
  useCacheRefresh,
  use,
  useMemoCache,
  useOptimistic,
} from './ReactHooks';
```

그럼 이제 ReactHook.js를 까보자. 여러 훅들이 정의되어 있지만 가장 간단한 훅인 useState의 구현체를 살펴보자. <mark>dispatcher</mark>를 선언하고 <mark>resolveDispatcher</mark>라는 함수를 할당한다.

```ts
export function useState<S>(
  initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
```

그럼 다시 resolveDispatcher를 까보자. 이 함수는 다음과 같이 정의되어 있다. 이 함수는 다시 <mark>ReactCurrentDispatcher</mark>를 가져온다.

```ts
function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  if (__DEV__) {
    if (dispatcher === null) {
      console.error(
        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +
          ' one of the following reasons:\n' +
          '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
          '2. You might be breaking the Rules of Hooks\n' +
          '3. You might have more than one copy of React in the same app\n' +
          'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',
      );
    }
  }
  // Will result in a null access error if accessed outside render phase. We
  // intentionally don't throw our own error because this is in a hot path.
  // Also helps ensure this is inlined.
  return ((dispatcher: any): Dispatcher);
}
```

ReactCurrentDispatcher함수는 다음과 같이 정의되어 있다. 그냥 객체 하나가 있고 current라는 필드가 있다.

```ts
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */

import type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';

/**
 * Keeps track of the current dispatcher.
 */
const ReactCurrentDispatcher = {
  current: (null: null | Dispatcher),
};

export default ReactCurrentDispatcher;
```

훅 객체는 외부 -> 내부에서 ReactCurrentDispatcher.current을 통해 주입받는다. 그리고 이 외부 -> 내부에서 의존성을 주입할 때 한단계를 더 거치게 되는데 <mark>ReactSharedInternal.js</mark>와 <mark>shared패키지</mark>가 이 역할을 한다.

그리고 reconciler패키지가 훅 객체를 주입한다.

### shared패키지와 ReactSharedInternal.js

먼저 ReactSharedInternal.js를 까보자.(Internal Server와 Client로 나누어져있는데 Client를 보겠다!)

이 파일은 외부에서 주입받길 기다리는 모듈들의 대기소이다.
(ReactCurrentDispatcher도 훅을 이곳에서 주입받는다.)

```ts
//ReactSharedInternal.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import ReactCurrentDispatcher from './ReactCurrentDispatcher';
import ReactCurrentCache from './ReactCurrentCache';
import ReactCurrentBatchConfig from './ReactCurrentBatchConfig';
import ReactCurrentActQueue from './ReactCurrentActQueue';
import ReactCurrentOwner from './ReactCurrentOwner';
import ReactDebugCurrentFrame from './ReactDebugCurrentFrame';
import {enableServerContext} from 'shared/ReactFeatureFlags';
import {ContextRegistry} from './ReactServerContextRegistry';

const ReactSharedInternals = {
  //현재 활성화된 훅 디스패처
  ReactCurrentDispatcher,
  ReactCurrentCache,
  ReactCurrentBatchConfig,
  ReactCurrentOwner,
};

if (__DEV__) {
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
  ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
}

if (enableServerContext) {
  ReactSharedInternals.ContextRegistry = ContextRegistry;
}

export default ReactSharedInternals;
```

shared는 말 그대로 모든 패키지가 공유하는 폴더이다. 이 곳에서도 ReactSharedInternals.js 파일을 찾을 수 있다.

```ts
shared -> ReactSharedInternals.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */

import * as React from 'react';

const ReactSharedInternals =
  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

export default ReactSharedInternals;
```

reconciler -> shared패키지의 ReactSharedInternal -> React코어의 ReactSharedInternal -> ReactCurrentDispatcher -> ReactHooks -> 훅

### useState훅

useState는 함수형 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다.

```ts
import {useState} from 'react'

//초기값을 넘겨주지 않으면 undefined
const [state,setState] = useState(initalState)
```

만약 useState를 사용하지 않고 함수 내부에서 상태를 관리한다면 어떻게 될까?

```ts
function Component() {
    let state = 'hello'

    function handleClickButton() {
        state = 'hi'
    }

    return (
        <>
          <h1>{state}</h1>
          <button onClick = {handleClickButton}>hi</button>
        </>
    )
}
```
리액트에서 렌더링은 함수형 컴포넌트의 <mark>return문</mark>과 클래스형 컴포넌트의 <mark>render함수</mark>를 실행한 후 이 실행 결과를 이전 트리와 비교해 리렌더링이 필요한 부분을 찾아서 발생시킨다. 리렌더링을 일으키는 요소 중에는 크게 아래와 같았다. 다시말해, 위 코드는 <mark>리렌더링을 일으키는 어떤 조건</mark>에 전혀 해당되지 않는다.

- useState setter
- useReducer dispatch
- this.setState
- this.forceUpdate
- useSyncExternalStore

그럼 아래와 같이 바꾸면 어떨까?

```ts
function Component() {
    const [,triggerRender] = useState()
    let state = 'hello'

    function handleButtonClick() {
        state = 'hi'
        triggerRender()
    }

    return (
        <>  
          <h1>{state}</h1>
          <button onClick = {handleButtonClick}>hi</button>
        </>
    )
}
```

위 경우 버튼을 클릭하면 렌더링이 일어난다. 그러나 상태가 갱신되지 않는데, 함수형 컴포넌트의 결과인 return의 값을 비교해 렌더링을 실행한다. 매번 렌더링이 일어날 떄마다, 저 Component가 다시 만들어지고 결국 새로운 함수에서 state는 hello로 매번 초기화되므로 상태가 변경되지 않는다.

그렇다면 useState의 결과는 <mark>어떻게 함수가 실행되어도 그 값을 갖고 있을까</mark>? useState훅을 다음과 같이 만들어보자.

```ts
function useState(initalState) {
    let initalState = initalState

    function setState(newState) {
        initalState = newState
    }

    return [initalState,setState]
}
```

이 코드는 정상적으로 동작하지 않는다. 구조분해할당으로 이미 <mark>initalState의 값을 결정한 상태</mark>이기 때문에, setState의 호출에도 불구하고 최신의 상태를 가져오지 못한다. 이를 해결하려면 setState를 함수로 바꿔서 state의 값을 반환하게 만들면 된다.

```ts
function useState(initalState) {
    let initalState = initalState

    function state() {
        return initalState
    }

    function setState(newState) {
        initalState = newState
    }

    return [initalState,setState]
}

const [state,setState] = useState(0)
setState(1)

console.log(state())
```

다만 실제 react에서는 값을 얻기 위해 함수를 사용하지 않는데, 이를 위해 react는 <mark>클로저</mark>를 사용한다.

```ts
const MyReact = function() {
    const global = {}
    let index = 0

    function useState(initalState) {
        //애플리케이션의 전체 state관리용
        if(!global.states) {
            global.states = []
        }

        //states 정보 조회 -> 현재 상태 값이 없다면 초기 값으로
        const currentState = global.states[index] ?? initalState
        //states의 값을 갱신
        global.states[index] = currentState

        //setter함수
        const setState = (function() {
            //클로저를 통해 즉시 실행 함수의 문맥으로 index가둔다. index를 계속 참조한다.
            let currentIndex = index
            return function(value) {
                global.states[currentIndex] = value
            }
        }())

        //하나의 state마다 index를 할당하고 그 index가 global.states를 가리킨다.
        index = index + 1

        return [currentState,setState]
    }

}
```
useState는 자바스크립트의 <mark>클로저</mark>에 의존해 구현된 것을 짐작할 수 있다. 클로저를 사용함으로써 외부에 값을 노출시키지 않고 컴포넌트가 렌더링되어도, <mark>useState에서 이전 값</mark>을 정확히 알 수 있다.

useState의 인수로 특정한 값을 넘기는 함수를 인수로 넣어줄 수 있다. 

```ts
// 함수를 실행해 값을 반환한다.
const [count,setCount] = useState(() => 
    Number.parseInt(window.localStorage.getItem(cacheKey))
)
```

게으른 초기화 함수는 <mark>오직 state가 처음 만들어질 때 실행된다.</mark> 이후 다시 리렌더링 된다면, 이 함수의 실행은 무시된다.

```ts

//매번 리렌더링 될떄마다(setState가 호출될때마다 localStorage를 읽는다.)
const Counter = () => {
    const initalState = Number.parseInt(window.localStorage.getItem(key))
    const [count,setCount] = useState(initalState)
}


//딱 초기화 할 때 한번만 호출된다.

const Counter = () => {
    const [count,setCount] = useState(() => 0)
}
```

<iframe src="https://www.youtube.com/embed/Z_eWhLpnhbk" width="480" height="360" frameborder="" allowfullscreen="true"></iframe>


이러한 방법은 useState의 초기값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하면 좋다. 

(localStorage나 sessionStorage에 대한 접근, map,filter등의 배열에 대한 접근 등)

### useEffect

[관련 글](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect)

useEffect의 정의를 정확하게 내리면, useEffect는 애플리케이션 내 컴포넌트의 여러 값을 활용해 동기적으로 부수효과를 만드는 방법이다. 그리고 이 부수효과는 어떤 상태값과 함께 실행되는지 살펴보는 것이 중요하다. useEffect의 의존성 배열이 바뀔 때마다 첫번째 콜백이 실행된다. 

그러면 어떻게 의존성 배열이 변경된 것을 알 수 있을까? 여기서 함수형 컴포넌트는 매번 <mark>함수를 실행해 렌더링</mark>을 수행한다는 점을 알아두자!

```ts
function Component() {
    const [count,setCount] = useState(0)

    useEffect(() => {
        console.log(count)   
    })
    function handleClick() {
        setCount((prev) => prev + 1)
    }

    return (
        <>
          <h1>{count}</h1>
          <button onClick = {handleClcik}>++</button>
        </>
    )
}
```

useEffect는 자바스크립트의 proxy, 옵저버 패턴 등과 같은 기능을 써서 변화를 감지하는 것이 아닌, 

<b>렌더링을 할 때마다 의존성에 있는 값을 보면서, 이 의존성의 값이 이전과 다른지</b> 확인하고 다르다면, 부수효과의 함수를 실행하는 함수이다.
그러면 클린업 함수는 대체 어떤 역할을 할까? 

일반적으로 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있다.

```ts
import {useState,useEffect} from 'react'

export default function App() {
    const [counter, setCounter] = useState(0)

    function handleClick() {
        setCounter((prev) => prev + 1)
    }

    useEffect(() => {
        function addMouseEvent() {
            console.log(counter)
        }  
        
        window.addEventListener('click',addMouseEvent)

        //클린업 함수
        return () => {
            console.log('클린업 함수 실행!',counter)
            window.removeEventListener('click',addMouseEvent)
        }
    },[counter])

    return (
        <>
          <h1>{counter}</h1>
          <button onClick = {handleClick}>++</button>
        </>
    )
}

//클린업 함수 실행 ! 0
//1

//클린업 함수 실행 ! 1
//2
```
- 버튼을 누른다. setState가 호출되어 count가 1 증가한다.
- count가 바뀌었으므로 useEffect가 실행되는데, 이때 이전 useEffect에서 반환한 클린업 함수가 먼저 실행된다.
- 이전 useEffect에서 반환한 클린업 함수는 함수가 선언되었을 상태인 count를 기억한다. 그러므로 0을 출력한다.
- 그 후 새로운 useEffect가 실행되고, 새로운 이벤트 리스너가 등록된다. 
- 클릭이 발생할 때마다 현재의 count를 찍는다(바뀐 상태 1을 찍는다).

이 과정을 직관적으로 코드로 보여주면 다음과 같다. 렌더링이 발생할 때마다 count가 어떤 값으로 선언되어있는지 보여준다.

```ts
useEffect(() => {
    function addMouseEvent() {
        console.log(0)
    }

    window.addEventListener('click',addMouseEvent)

    //클린업 함수
    //다음 렌더링이 끝나고 실행된다.

    return () => {
        console.log(0)
        window.removeEventListener('click',addMouseEvent)
    }
},[count])

//그 이후 실행
useEffect(() => {
    function addMouseEvent() {
        console.log(1)
    }

    window.addEventListener('click',addMouseEvent)

    //클린업 함수
    //다음 렌더링이 끝나고 실행된다.

    return () => {
        console.log(1)
        window.removeEventListener('click',addMouseEvent)
    }
},[count])
```

결국 useEffect안의 콜백이 존재한다면, <mark>이전의 클린업 함수를</mark> 반드시 실행하게 된다. 만약 이벤트를 걸어주는 콜백을 달고 클린업 함수를 반환하지 않았다고 생각해보자.

콜백이 실행될 떄마다 매번 이벤트가 달아지고, 이 이벤트는 제거되지 않는 무한 이벤트 추가와 같은 끔찍한 일이 벌어질 수 있다. 클린업 함수는 함수형 컴포넌트가 리렌더링 되었을 때, 의존성 변화가 있었을 당시 값을 기준으로 실행된다!.!


### 의존성 배열

의존성 배열은 보통 빈 배열을 두거나, 아예 아무런 값도 넘기지 않거나, 혹은 사용자가 직접 원하는 값을 넣어줄 수 있다. 만약 빈 배열을 두면, 최초 렌더링 이후 더 이상 실행되지 않고 아무런 값도 넘겨주지 않는다면 렌더링 될때마다 실행된다. (보통 컴포넌트가 렌더링 되었는지 확인할 때 사용할 수 있다.)

```ts
useEffect(() => {
    console.log('컴포넌트 렌더링됨!')   
})
```

두 코드의 차이점을 살펴보자

```ts
function Component() {
  console.log('foo')
}

function Component() {
  useEffect(() => {
    console.log('bar')
  })
}
```

- useEffect는 클라이언트 사이드에서의 실행을 보장
- useEffect 내부는 컴포넌트의 렌더링이 완료된 이후에 실행된다.
    - 직접 실행은 컴포넌트가 렌더링되는 도중에 실행된다

의존성 배열의 이전값과 현재 값의 얕은 비교(Object.is)로 구현되어 있다. 

이전 의존성 배열과 현재 의존성 배열의 값에 변경사항이 있으면 callback으로 선언한 부수효과를 실행한다.

### useEffect를 사용할 때 주의할 점

(개인적으로 정말 궁금했던 점)

린트의 규칙은 최대한 살리면서 개발하자.

대부분 빈 배열을 의존성으로 넣어줄 때, 즉 컴포넌트를 마운트 하는 어떤 시점에 무언가를 하고 싶다는 의도로 작성한다.(정작 나도 많이..) 그러나 이는 클래스형 컴포넌트의 <mark>componentDidMount</mark>에 기반한 접근법으로 <b>가급적 사용하면 안된다.</b>

useEffect는 반드시 의존성 배열로 전달한 값의 변경에 따라 실행해야 하는 훅이다.

그러나 의존성 배열을 넘기지 않은 채 콜백함수에 특정 값을 사용한다는 것은, 이 부수 효과가 실제 변화를 관찰하고, 실행해야 하는 값과 별개로 동작해야 한다는 것을 의미한다. 즉 컴포넌트의 state,props의 변경과 useEffect의 부수 효과가 <b>별개로 동작하게 된다!</b>

```ts
function Component({log} : {log:string}) {
    useEffect(() => {
        logging(log)
    },[])
}
```
이렇게 컴포넌트가 최초 마운트 되었을 때 로깅을 남기는 용도로 코드를 작성했다고 가정해보자.

그러나 당장 문제가 없더라도, 버그의 위험성을 안고 있다..! log가 아무리 변하더라도, useEffect의 부수효과는 실행되지 않는다.

useEffect를 비동기 함수로 사용하는 경우, race-condition 문제가 발생할 수 있다. 만약 비동기 함수를 사용한다면 클린업 함수에 이전 비동기 함수에 대한 처리를 추가하는 것이 좋다. (클린업함수의 실행 순서를 보장할 수 없다)

가능한 한 useEffect는 간결하고 가볍게 유지하는 것이 좋다

### useMemo

useMemo는 비용이 큰 연산의 결과를 저장(메모리제이션)해두고 이 저장된 값을 반환하는 훅이다.

첫번쨰 인자로 어떤 값을 반환하는 생성함수로, 두번째 인자로는 해당 함수가 의존하는 값의 배열을 전달한다.

useMemo는 의존성 배열의 값이 변경되지 않았다면 이전에 기억해 둔 값을 반환하고, 변경되었다면 첫번째 함수를 실행하고 그 값을 반환하고 기억한다.(컴포넌트 또한 useMemo로 메모리제이션 해둘 수 있다.)

```ts
//컴포넌트의 props를 기준으로 컴포넌트 자체를 기억해버린다!

function ExpensiveComponent({value}) {
    useEffect(() => {
        console.log('렌더링')
    })
    return <span>{value}</span>
}

function App() {
 const memoComponent = useMemo(() => <ExpensiveComponent value = {value} />,[value])   

 return (
    <div>
        {memoComponent}
    </div>
 )
}
```

"비용이 많이 드는 연산"이라면 useMemo를 사용할 수 있다!

결론 : 비용이 큰 연산에 대한 결과를 메모이제이션하고 저장된 값을 반환하는 훅

- useMemo를 사용해 컴포넌트 메모이제이션도 가능
- 물론 React.memo를 쓰는 것이 더 현명

### useCallback

useMemo가 값을 기억한다면, useCallback은 인수로 넘겨받은 콜백 자체를 기억한다. 즉, 특정 함수를 새로 만들지 않고 재사용하게 된다.

```ts
const ChildComponent = memo(({ name , value , onChange})) => {
    useEffect(() => {
        console.log('렌더링!',name)
    })

    return (
        <>
          <h1>{name} {value ? '켜짐' ? '꺼짐'}</h1>
          <button onClick = {onChange}>toggle</button>
        </>
    )
}

function App() {
    const [state1,setState1] = useState(false)
    const [state2,setState2] = useState(false)

    const toggle1 = () => {
        setState1(!state1)
    }

    const toggle2 = () => {
        setState2(!state2)
    }

    return (
        <>
          <ChildComponent name = "1" value = {state1} onChange = {toggle1} />
          <ChildComponent name = "2" value = {state2} onChange = {toggle2} />
        </>
    )
}
```

memo를 이용해 컴포넌트를 메모리제이션해두었지만, App의 자식 전체가 렌더링되고 있다. ChildComponent의 memo를 씌우면 name,value,onChange의 값을 모두 기억하고 , 이 값들이 변경되지 않는 한 다시 렌더링 되지 않는다.

그러나 어느 한 버튼을 누르게 된다면 -> 이 버튼이 setState을 호출하고 -> App컴포넌트가 다시 렌더링되고 onChange함수가 <mark>새로 다시 만들어진다.</mark> 따라서 의도한 대로 동작하지 않게 된다.

```ts
//상태값이 변경될 때만 함수가 재생성되고, 그 외에는 이전에 메모리에 저장한 함수를 재사용

//ChildComponent는 자신에게 전달된 onChange 함수가 변경되지 않는 한 불필요한 렌더링을 방지하게 된다.

function App() {
    const [state1,setState1] = useState(false)
    const [state2,setState2] = useState(false)

    const toggle1 = useCallback(() => {
        setState1(!state1)
    }, [state1])

    const toggle2 = useCallback(() => {
        setState2(!state2)
    }, [state2])

    return (
        <>
          <ChildComponent name = "1" value = {state1} onChange = {toggle1} />
          <ChildComponent name = "2" value = {state2} onChange = {toggle2} />
        </>
    )
}

```

- useCallback은 useMemo를 사용해 구현할 수 있다 (Preact의 경우 이렇게 구현되어 있다)
- 둘의 유일한 차이는 대상이 변수냐 함수냐일 뿐이다
- 자바스크립트에서는 함수 또한 값으로 표현될 수 있으므로 이러한 코드는 매우 자연스럽다고 볼 수 있다
- 다만 useMemo로 useCallback을 구현하는 경우 코드가 불필요하게 길어지고 혼동을 야기할 수 있으므로 리액트에서 별도로 제공하는 것으로 추측해 볼 수 있다

### useRef

useState와 동일하게 컴포넌트 내부의 렌더링이 발생해도 변경 가능한 상태값을 지닌다. 그러나 useState와 두가지의 차이가 있다.

- useRef는 반환값인 객체 내부에 있는 current로 값에 접근,변경이 가능하다.
- useRef는 값이 변해도 렌더링을 발생시키지 않는다.

렌더링에 영향을 미치지 않으면 그냥 함수 외부에서 값을 선언하고 관리하는 게 좋지 않을까?

```ts
 let value = 0
  function Component() {
    return <>{value}</>
  }
```

이 방식은 크게 다음과 같은 단점이 있다.

- 컴포넌트가 실행되어 렌더링되지 않아도 value라는 값이 존재한다. 메모리에 불필요한 값을 갖게 하는 부작용이 있다.
- 컴포넌트가 여러번 생성된다면 각 컴포넌트에서 모두 동일한 value를 바라보게 된다.

useRef는 이 두가지 단점을 해결한다. 컴포넌트가 렌더링 될떄만 생성되고 무조건 별개의 값을 바라본다.

Preact는 useRef을 useMemo로 구현한다. 렌더링에 영향을 미치면 안되기 떄문에 useMemo에 빈 배열을 두고, 각 렌더링마다 동일한 객체를 바라보게 된다.

자바스크립트의 특징, 객체의 값을 변경해도 객체를 가리키는 주소가 변경되지 않는다는 것을 떠올리면 useMemo로 useRef를 구현할 수 있다

```ts
export function useRef(initalValue) {
    currentHook = 5
    return useMemo(() => {current : initalValue} , [])
}
```

### useContext

리액트 애플리케이션은 부모컴포넌트와 자식 컴포넌트로 이루어진 트리 구조를 갖기 떄문에 부모의 데이터를 사용하고 싶다면 props로 데이터를 넘겨준다. 그러나 전달해야하는 부모-자식의 깊이가 깊어지면 props drilling 현상이 발생한다. 콘텍스트를 사용하면 명시적인 props 전달 없이도 하위 컴포넌트 전부에서 원하는 값을 자유롭게 쓸 수 있다.

![](data:image/jpeg;base64,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)

useContext를 사용하면 상위 컴포넌트 어딘가에 선언된 <Context.Provider>의 값을 가져온다. useContext 내부에서 해당 콘텍스트가 존재하는 환경인지 , 초기화 되어 값을 내려주는지 확인하는 것이 좋다.

```ts
function useMyContext() {
    const context = useContext(myContext)
    if(context === undefined){
        throw new Error(
            'Context Error!'
        )
    }
}
```

useContext를 함수형 컴포넌트에서 쓰면 <mark>컴포넌트의 재활용이 어려워진다</mark>는 점을 염두에 두자! 

useContext가 선언되어있으면 <mark>Provider와 강한 의존성을 갖게 된다.</mark>

이러한 상황을 막으려면, useContext를 사용하는 컴포넌트를 최대한 작게하거나, 재사용되지 않을 컴포넌트에만 사용해야 한다. 콘텍스트와 useContext는 상태 관리를 위한 리액트의 API가 아닌 <mark>상태를 주입하는 API</mark>이다.

일반적인 상태 관리 라이브러리는 다음을 만족한다.그러나 콘텍스트는 이 둘 중 아무것도 하지 못한다.

- 어떤 상태를 기반으로 다른 상태를 만들어낸다.
- 필요에 따라 상태 변화를 최적화한다.

상태가 변화하면 프로바이더 트리 전체가 리렌더링된다 . 물론 React.memo를 사용해 최적화할 수 있다
