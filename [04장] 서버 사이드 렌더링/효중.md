
### 싱글 페이지 애플리케이션

싱글 페이지 애플리케이션은 렌더링과 라우팅에 필요한 대부분의 기능을 브라우저의 자바스크립트에 의존하는 것을 말한다. 최초로 첫 페이지에서 데이터를 불러 온 후, 페이지 전환이 브라우저의 <mark>history.pushState</mark>나 <mark>history.replaceState</mark>로 이뤄지기 때문에 페이지를 불러온 후부터는 서버에서 HTML을 추가로 내려받지 않는다.

![](https://geekflare.com/wp-content/uploads/2021/10/singlepageapplication.png)

싱글 페이지 애플리케이션에서 전체 사이를 모두 볼 수 있지만, 실제 소스 보기로 HTML을 보면 <body></body> 내부에 아무 내용이 없다.

사이트 렌더링에 필요한 body내부의 내용은 자바스크립트 코드를 삽입한 이후 렌더링하기 떄문이다. 또 페이지 전환 시에도 새 HTML을 요청하는 것이 아니라 다음 페이지의 렌더링에 필요하나 정보만 가져온 후 body 내부의 DOM으르 추가,삭제,수정하는 방법으로 페이지가 전환된다.

이런 싱글 페이지 애플리케이션은 자바스크립트 리소스가 커지는 단점이 있지만, 한번 로딩된 이후 서버를 거쳐 다시 리소스를 가져올 일이 적어져서 사용자에게 부드러운 페이지 전환을 재공한다.

### 서버 사이드 렌더링

싱글 페이지 애플리케이션이 자바스크립트를 통해 하나의 페이지에서 렌더링을 수행한다면, 서버 사이드 렌더링은 최초 사용자에게 보여주는 페이지를 서버에서 렌더링해 빠르게 사용자에게 보여주는 방식을 의미한다. 싱글 페이지 애플리케이션에서 자바스크립트의 크기가 커지면 커질수록 웹 페이지가 느려지는 것을 방지하고자, 서버에서 페이지를 렌더링해 제공하는 서버사이드-렌더링이 다시 주목을 받고 있다.

![](https://www.inrhythm.com/wp-content/uploads/2023/10/server-side-rendering.png)

싱글 페이지 애플리케이션과 서버에서 페이지를 빌드하는 서버 사이드 렌더링은 웹 페이지의 렌더링의 책임을 어디에 두냐이다. 싱글 페이지 애플리케이션은 사용자에게 제공되는 자바스크립트 번들에서 렌더링을 책임지지만, 서버 사이드 방식은 렌더링의 역할을 모두 서버에서 수행한다.

서버사이드 렌더링의 장점으로는 다음의 것들이 존재한다.

- 최초 페이지 진입이 비교적 빠르다.
    사용자가 최초 페이지에 진입했을 때 페이지의 정보가 그려지는 시간 (FCP)가 더 빨라질 수 있다.
    최초에 사용자가 보게 될 화면이 외부 API에 의존적이라면, 싱글 페이지 애플리케이션의 경우 
    페이지 진입 -> 자바스크립트 번들 다운 -> HTTP 요청 -> 렌더링 과정을 거친다.

    그러나 이런 작업은 서버에서 더 빠르게 진행될 수 있다.(서버가 리소스를 확보한 상태라면)

- 검색 엔진과 SNS 공유 등의 메타데이터 가공이 쉽다.

- 누적 레이아웃 이동이 적다.
    누적 레이아웃 이동은 사용자에게 페이지를 보여준 이후 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되면서 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험을 말한다.
    싱글 페이지 애플리케이션에서는 페이지 콘텐츠가 API요청에 의존할 수 있다. 이때 API요청의 응답 속도가 제각각이면 이런 누적 레이아웃 이동이 발생할 수 있다.
    이는 그러나 React18의 스트림으로 해결이 가능하다.

- 사용자의 디바이스 성능에 비교적 자유롭다.

다음으로 단점으로는 다음의 것들이 존재한다.

- 소스코드 작성시 항상 서버를 고려해야 한다. (window,sessionStorage 등등..)

- 적절한 서버가 구축되어 있어야 한다.
    사용자의 요청을 받아 렌더링을 적절히 수행할 서버가 필요하고, 예기치 않은 장애 상황에 대응하는 전략도 필요하다.
    [Next EC2-배포-PM2-활용한-무중단-배포](https://velog.io/@pikadev1771/EC2-%EB%B0%B0%ED%8F%AC-PM2-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC)

현대의 서버 사이드 렌더링은 기존의 서버 사이드 렌더링와 약간 다르다. 최초 웹 사이트 진입 시에는 서버 사이드 렌더링으로 서버에서 완성된 HTML을 제공받고,이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 싱글 페이지 애플리케이션처럼 작동한다.

### 서버 사이드 렌더링을 위한 리액트의 API 알아보기

리액트는 브러우저 자바스크립트 환경에서 렌더링 할 수 있는 방법을 제공하지만, 동시에 애플리케이션을 서버에서 렌더링하는 API도 제공한다. 이 api는 Node환경에서만 실행할 수 있다.

- renderToString : 리액트 컴포넌트를 렌더링 해 HTML 문자열로 바꾸는 함수다.

```ts
import ReactDOMServer from 'react-dom/server'

function ChildComponent({fruits} : {fruits : Array<string>}) {
    useEffect(() => {
        console.log(fruits)
    },[fruits])

    function handleClick() {
        console.log('hello')
    }

    return (
        <ul>
          {fruits.map((fruit) => (
            <li key = {fruit} onClick = {handleClick}>{fruit}</li>
          ))}
        </ul>
    )
}

function SampleComponent() {
    return (
        <>
          <div>hello</div>
          <ChildComponent fruits = {['apple','banana','peach']} />
        </>
    )
}

const result = ReactDOMServer.renderToString(
    React.createElement('div', {id:'root'}, <SampleComponent />)
)
```

이 result는 다음과 같이 변환된다.

```ts
<div id = "root" data-reactroot ="">
    <div>hello</div>
    <ul>
        <li>apple</li>
        <li>banana</li>
        <li>peach</li>
    </ul>
</div>
```
useEffect훅이나 handleOnClick 등의 이벤트 핸들러는 결과물에서 제외된다. 웹페이지가 사용자와 인터렉션할 준비가 되기 위해서는 별도의 자바스크립트 코드를 모두 다운받고, 파싱하고 실행해야 한다. data-reactroot는 리액트 컴포넌트의 루트가 무엇인지 식별하는 역할을 한다.

이 속성은 이후 자바스크립트를 실행하기 위한 hydrate함수에서 루트를 식별하는 기준이 된다.

- renderToStaticMarkUp : 앞서 renderToString과 유사하나 data-reactroot등의 리액트에서만 쓰는 추가적인 DOM 속성을 만들지 않는다.
    이 함수는 이벤트 리스너가 필요없는 완전한 정적의 HTML을 만들 때 유용하다.

- renderToNodeStream : renderToString과 결과물이 동일하지만 크게 2가지의 차이점이 있다.
    앞서 함수와 달리 브라우저에서 사용하는 것이 금지된다. renderToNodeStream은 결과물이 Node의 ReadableStream이다.
    (utf-8로 인코딩된 바이트 스트림!)

    왜 그럼 이 함수가 필요할까 ? 

    유튜브 영상을 보기 위해 전체 영상을 다운받을 때까지 기다리지 않는다. 사용자가 볼 수 있는 조금이라도 다운로드되면 그 부분을 먼저 보여준다. 스트림은 <mark>큰 데이터를 다룰 시 청크</mark>단위로 분할해 조금씩 가져오는 방식을 말한다.

    만약 renderToString의 결과물이 매우 크다면 어떨까? 크기가 큰 문자열을 한번에 올려두고 응답을 수행하면 Node 서버에 큰 부담이 될 수 있다.

```ts
export default function App({todos} : {todos:Array<TodoResponse>}) {
    return (
        <>
          <ul>
            {todos.map((todo) => (
                <Todo key = {index} todo = {todo} />
            ))}
          </ul>
        </>
    )
}

//renderToNodeStream
;(async => {
    const response = await fetch('http://localhost:3000')
    try{
        for await (const chunk of response.body) {
            console.log(Buffer.from(chunk).toString())
        }
    }
    catch(error) {
        console.error(error)
    }
})()
```

이렇게 하면 응답으로 오는 HTML이 여러 청크로 분리되어 내려오는 것을 볼 수 있다.

- hydrate : 이 함수는 renderToString이나 renderToNodeStream으로 생성된 HTML 콘텐츠에 자바스크립트 이벤트 핸들러나 이벤트를 붙이는 역할을 한다. 앞서 renderToString은 HTML 렌더링된 결과물을 사용자에게 보여줄 수 있지만, 사용자와 페이지에서 상호작용하는 것은 불가능하다.이렇게 hydrate는 정적으로 생성된 HTML에 이벤트와 핸들러를 붙여 웹페이지 결과물을 만든다.

```ts
import * as ReactDOM from 'react-dom'
import App from './App'

const element = document.getElementById(containerId)
ReactDOM.hydrate(<App />,element)
```

render와 달리 이미 렌더링된 HTML이 있다는 가정하에 작업을 하고, 이 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업만 진행된다. 




