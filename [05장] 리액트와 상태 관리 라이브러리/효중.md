애플리케이션 전체적으로 관리해야 할 상태가 있을 때, 이런 상태 변화가 일어남에 따라 즉각적으로 모든 요소들이 변경되어 애플리케이션이 찢어지는 현상을 어떻게 막을 수 있을까?

다른 웹 개발 환경과 마찬가지로, 리액트도 상태관리에 대한 필요성이 존재했다. 프레임워크를 지향하는 Angular와 다르게 리액트는 단순히 사용자 인터페이스를 만들기 위한 라이브러리일 뿐 , 그 이상의 기능은 제공하지 않고 있다. 따라서 상태를 관리하는 방법도 시간에 따라 많은 변화가 존재했다.

### Flux 패턴

리액트에서는 전역 상태관리를 어떻게 했을까? 리덕스가 나타나기 전까지 리액트 애플리케이션에서 이름을 널리 알린 상태 관리 라이브러리는 없었다. Flux가 나올 당시 웹 애플리케이션이 비대해지고 상태도 많아짐에 따라 어디서 어떤 일이 일어나서 이 상태가 변경되었는지 등을 추적하는 것이 매우 어려운 상황이었다.

![](https://blog.coderifleman.com/images/mvc-does-not-scale-use-flux-instead/flux_architecture.01.png)

위 그림처럼 Model은 View를 변경할 수 있고, View는 Model을 변경할 수 있다. 코드가 적고 간단한 애플리케이션은 이런 패턴이 괜찮지만, 변경 시나리오가 많아지고 애플리케이션이 거대해질수록 관리가 어려워진다. 양방향이 아닌 단방향의 데이터 흐름을 변경하는 것이 Flux 패턴의 시작이다.

![](https://blog.kakaocdn.net/dn/cxAE6m/btqJt03TWSO/2VlPelrdlncyUINFldlWZ0/img.png)

- 액션 : 어떤 작업을 처리할 액션과 , 액션 발생 시 함께 포함시킬 데이터를 의미한다. 액션 타입과 데이터를 정의해 디스패쳐로 보낸다.
- 디스패쳐 : 액션을 스토어로 보내는 역할을 한다. 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
- 스토어 : 실제 상태에 따른 값과 , 상태를 변경할 수 있는 메서드를 갖고 있다. 액션의 타입에 따라 어떻게 이를 변경할지 정의되어 있다.
- 뷰 : 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 뷰에서 액션을 호출한다.

```ts
type StoreState = {
    count : number
}

type Action = {
    type:'add',
    payload:number
}

function reducer(prevState : StoreState, action: Action) {
    const { type : ActionType } = action;
    if(ActionType === 'add') {
        return {
            count : prevState.count + action.payload
        }
    }
}

export default function App() {
    const [state,dispatcher] = useReducer(reducer, {
        count:0
    })

    const handleClick = () => {
        dispatcher({
            type:'add',
            payload:1
        })
    }

    return (
        <div>
            <h1>{state.count}</h1>
            <button onClick = {handleClick}>+</button>
        </div>
    )
}
```

이러한 흐름속에 리덕스가 등장한다. 리덕스는 최초에는 이 Flux 구조를 구현하기 위해 만들어진 라이브러리 중 하나이다. 리덕스는 하나의 상태 객체를 <b>스토어</b>에 넣어두고, 이 객체를 업데이트 하는 작업을 <b>디스패치</b>해 업데이트를 수행한다. 이 작업은 <b>reducer</b>함수로 발생시킬 수 있는데, 이 함수의 실행은 웹 애플리케이션 상태에 대해 <b>완전히 새로운 복사본</b>을 반환한 다음, 애플리케이션에 새로 만들어진 상태를 전파한다.

이런 리덕스의 등장은 props drilling 문제를 해결할 수 있었고 스토어에 바로 접근할 수 있게 되었다. (store.getState())

Props를 간편하게 넘겨주기 위해 16.3 버전에서 Context API 출시했으나 다만 아래와 같은 문제점이 있었다. 상위 컴포넌트가 렌더링 되면 shouldComponentUpdate가 항상 true를 반환하여 불필요한 렌더링이 일어난다. context를 인수로 받기 때문에 컴포넌트와 결합도가 높다.
렌더링을 막아주는 기능이 없다.

### 리액트 훅으로 시작하는 상태 관리

오랜 시간동안 리액트 애플리케이션의 상태 관리를 위해 리덕스에 의존했다. 그러나 현재는 새로운 Context API, useReducer, useState의 등장으로 컴포넌트에 결처셔 재사용하거나 컴포넌트 내부에 걸쳐서 상태를 관리할 수 있는 방법들이 점차 많이 등장하기 시작했고, 리덕스 외의 다른 라이브러를 선택하는 경우도 많아지고 있다. 

가장 기본적으로 useState와 useReducer를 사용할 수 있다.

```ts
function useCounter(initCount = 0) {
    const [counter,setCounter] = useState(initCount)

    function inc() {
        setCounter((prev) => prev + 1)
    }

    return {
        counter,inc
    }
}
```
useState와 useReducer가 상태 관리의 모든 필요성과 문제를 해결해주진 않는다. useState나 useReducer를 기반으로 하는 커스텀 훅의 한계는 명확하다. 훅을 쓸 때마다 컴포넌트가 초기화되므로 컴포넌트에 따라 다른 상태를 가질 수 밖에 없다. 이렇게 useState나 useReducer를 기반으로 한 상태를 지역상태라고 한다. 지역상태는 컴포넌트 내에서만 유효하다는 한계가 있다.

함수 외부에서 어떤 상태를 참조하고 이를 통해 렌더링까지 자연스럽게 일어나려면 다음의 조건이 필요하다.
- 컴포넌트 외부에 상태를 두고 여러 컴포넌트가 동시에 접근해 사용할 수 있다.
- 이 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아내야 하고, 상태가 변경될 때마다 리렌더링이 일어나서 항상 최신 값을 바라봐야 한다. 이 상태 감지는 해당 상태를 참조하는 모든 컴포넌트에서 필요하다.
- 상태가 객체인 경우, 객체에 내가 감지하고 있지 않은 값이 바뀌더라도 리렌더링이 발생해서는 안된다.

위 조건을 충족하는 store를 만들어보자! store의 변경이 있을 때마다 변경이 되었음을 알리는 콜백함수를 실행하고, 이 콜백함수를 등록하는 subscribe 함수가 필요하다.

```ts
type Initalizer<T> = T extends any ? T | ((prev:T) => T) : never

type Store<State> = {
    get: () => State,
    set: (action:Initalizer<State>) => State,
    subscribe : (callback:() => void) => () => void
}

export const createStore = (initState:Initalizer<State>) : Store<State> = > {
    let state = typeof initState !== 'function' ? initState : initState()

    const callbacks = new Set<() => void>()

    const get = () => state

    const set = (newState : State ? ((prev:State) => State)) => {
        state = typeof newState === 'function' ? (newState as (prev:state) => State)(state) : newState

        callbacks.forEach((callback) => callback())
        return state
    }
   // 'newState'의 타입이 함수인 경우, 이전 상태를 매개변수로 받아 새로운 상태를 반환하는 함수로 간주합니다.
   // 'newState'의 타입이 'State'인 경우, 바로 해당 상태를 새로운 상태로 설정합니다.

   const subscribe = (callback:() => void) => {
    //받은 함수를 콜백에 추가합니다.
    callbacks.add(callback)

    return () => callbacks.delete(callback)
   }
}
```

이제 createStore로 만들어진 store의 값을 참조하고 이 값의 변화에 따라 컴포넌트를 렌더링하는 커스텀 훅이 필요하다.

```ts
export const useStore = (store:Store<State>) => {
    const [state,setState] = useState<State>(() => store.get())
    useEffect(() => {
        const storeSubScribe = store.subscribe(() => {
            setState(store.get(()))
        })

        return storeSubScribe
    },[store]) 
    return [state,store.set]
}
```

- 훅의 인수로 사용할 store를 받는다.
- 이 스토어의 값을 초기값으로 갖는 useState를 만든다. 이제 이 useState가 컴포넌트의 렌더링을 유도한다.
- useEffect로 store의 현재 값을 가져와 setState를 수행하는 함수를 store의 subscribe에 등록해 두었다.
- createStore 내부에서 값이 바뀔 때마다 subscribe에 등록된 콜백을 실행하므로, store의 값이 바뀔 때마다 state가 바뀌는 것을 보장한다.
- 클린업 함수로 unsubscribe를 등록해둔다. 


그러나 앞서 useStore에서 객체 타입의 값인 경우 스토어의 객체 중 하나의 프로퍼티라도 바뀐다면 리렌더링이 다시 일어날 것이다.

```ts
export const useStore = (store:Store<State>,selector:(state:State) => State) => {
    const [state,setState] = useState<State>(() => selector(store.get()))
    useEffect(() => {
        const storeSubScribe = store.subscribe(() => {
            setState(selector(store.get()))
        })

        return storeSubScribe
    },[store,selector]) 
    return [state,store.set]
}
```
두번째 인수로 selector의 함수를 받는다. useState는 값이 변경되지 않으면 렌더링을 수행하지 않으므로 store의 값이 변경되어도 selector(store.get())이 변경되지 않으면 렌더링을 수행하지 않는다.

```ts
const store = createStore({
    count:0,
    text:'hi'
})

const counter = useStore(store,useCallback((state) => state.count),[]) 
```
